# 并发编程知识汇总

## 1. 多线程基础

### 1.1 创建线程的三种方式

1. **继承 Thread 类**：创建一个类继承 `Thread` 类，并重写 `run` 方法。
   ```java
   public class MyThread extends Thread {
       @Override
       public void run() {
           System.out.println(getName() + ": 执行任务");
       }
   }
   ```
2. **实现 Runnable 接口**：创建一个类实现 `Runnable` 接口，并重写 `run` 方法。更灵活，易于与线程池配合。
   ```java
   public class MyRunnable implements Runnable {
       @Override
       public void run() {
           System.out.println(Thread.currentThread().getName() + ": 执行任务");
       }
   }
   ```
3. **实现 Callable 接口 (FutureTask)**：实现 `Callable` 接口，重写 `call` 方法。这种方式可以通过 `FutureTask` 获取任务执行的返回值。
   ```java
   public class CallerTask implements Callable<String> {
       public String call() throws Exception {
           return "Hello, task result!";
       }
   }
   // 使用方式
   FutureTask<String> task = new FutureTask<>(new CallerTask());
   new Thread(task).start();
   String result = task.get(); // 获取结果
   ```

| 创建方式                         | 优点                                                 | 缺点                                                              |
| :------------------------------- | :--------------------------------------------------- | :---------------------------------------------------------------- |
| **实现 Runnable/Callable** | 避免 Java 单继承局限；适合资源共享；解耦线程与任务。 | 编程稍微复杂，如需访问当前线程需使用 `Thread.currentThread()`。 |
| **继承 Thread**            | 编程简单，直接使用 `this` 即可获取当前线程。       | 受限于 Java 单继承；不适合多线程处理同一资源。                    |

### 1.2 run() 与 start() 的区别

* **为什么要重写 run()**：默认的 `run()` 方法不执行任何操作。为了让线程执行具体任务，必须重写它。
* `run()`：封装线程执行的代码，直接调用相当于在主线程中执行普通方法。
* `start()`：启动线程，使线程进入“就绪”状态，由 JVM 在合适时机调用此线程的 `run()` 方法。**只有 start() 才能真正开启多线程。**

## 2. 获取线程执行结果 (Future)

### 2.1 Future 接口

提供了异步计算的各种功能：

* `cancel(boolean mayInterrupt)`：尝试取消任务。若任务已完成或无法取消则返回 false。
* `isCancelled()`：任务是否在正常完成前被取消。
* `isDone()`：任务是否已完成（包括正常完成、异常、取消）。
* `get()`：**阻塞**获取结果，直到任务完成。
* `get(timeout, unit)`：在指定时间内获取结果，超时则返回 null 或抛异常。

### 2.2 FutureTask

`FutureTask` 实现了 `RunnableFuture` 接口（继承自 `Runnable` 和 `Future`），既可以作为 `Runnable` 被线程执行，又可以作为 `Future` 获取结果。

## 3. 线程运行原理

### 2.1 栈与栈帧

* 线程启动后，虚拟机会为每个线程分配一段**栈内存**。
* 栈由多个**栈帧**（Stack Frame）构成，对应着每次方法调用时占用的内存。
* 每个线程只能有一个**活动栈帧**，对应着当前正在执行的那个方法。

### 2.2 线程上下文切换（Context Switch）

发生情况：

* 线程的 CPU 时间片用完。
* 垃圾回收。
* 有更高优先级的线程需要运行。
* 线程自己调用了 `sleep`、`yield`、`wait`、`join`、`park`、`synchronized`、`lock` 等方法。

当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是**程序计数器**（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的。

## 3. 查看进程与线程

### 3.1 操作系统命令

* **Windows**:
  * `tasklist`: 查看所有进程。
  * `taskkill /F /PID <pid>`: 强制杀死进程。
* **Linux**:
  * `ps -fe`: 查看所有进程。
  * `top`: 动态查看进程信息。
  * `kill <pid>`: 杀死进程。

### 3.2 Java 工具

* `jps`: 查看所有 Java 进程。
* `jstack <PID>`: 查看某个 Java 进程内的线程堆栈信息（排查死锁、CPU 飙高常用）。
* `jconsole`: 图形化界面，查看 Java 进程内线程的运行情况。

## 4. 线程常用方法

| 方法名                                | 作用                 | 说明                                                                                             |
| :------------------------------------ | :------------------- | :----------------------------------------------------------------------------------------------- |
| `start()`                           | 启动新线程           | 每个线程只能调用一次（**不可重复调用**）。                                                 |
| `run()`                             | 线程启动后执行的逻辑 | 直接调用不会启动新线程。                                                                         |
| `join()` / `join(n)`              | 等待线程结束         | 使调用方等待该线程结束（或超时）。                                                               |
| `sleep(n)`                          | 线程休眠             | 状态变为 `TIMED_WAITING`，**不释放锁**。建议在 `while(true)` 循环中调用以防 CPU 空转。 |
| `yield()`                           | 提示让出 CPU         | 状态变为 `RUNNABLE`，具体是否让出依赖调度器。                                                  |
| `interrupt()`                       | 打断线程             | 设置打断标记；若线程在 sleep/wait/join 会抛异常并清除标记。                                      |
| `isInterrupted()`                   | 判断是否被打断       | 不会清除打断标记。                                                                               |
| `Thread.interrupted()`              | 判断是否被打断       | **静态方法，会清除打断标记**。                                                             |
| `setDaemon(true)`                   | 设置为守护线程       | 主线程结束，守护线程也会被强制结束（如 GC 线程）。                                               |
| `getId()`                           | 获取线程唯一 ID      | 线程的长整型标识符。                                                                             |
| `getName()` / `setName()`         | 获取/修改线程名      | 方便调试和排查问题。                                                                             |
| `getPriority()` / `setPriority()` | 获取/修改优先级      | 范围 1-10，具体实现依赖任务调度器。                                                              |
| `isAlive()`                         | 线程是否存活         | 线程已启动且尚未结束。                                                                           |
| `currentThread()`                   | 获取当前线程         | 静态方法。                                                                                       |

### 4.1 过时方法（不推荐使用）

以下方法由于容易导致死锁或资源无法释放，已不推荐使用：

* `stop()`: 强制停止线程，可能导致同步资源未释放。
* `suspend()` / `resume()`: 挂起和恢复线程，极易导致死锁。

### 4.2 两阶段终止模式

如何优雅地在一个线程中终止另一个线程？利用 `interrupt`。
![1764300709161](image/1764300709161.png)

## 5. 线程生命周期与状态

![1762734021190](image/1762734021190.png)

### 5.1 操作系统层面（五种状态）

![1764301356509](image/1764301356509.png)

1. **初始状态**: 已创建但未与操作系统关联。
2. **可运行状态**: 等待 CPU 调度。
3. **运行状态**: 正在执行，时间片用完会回到可运行状态。
4. **阻塞状态**: 调用阻塞 API（如读写文件），结束后回到可运行状态。
5. **终止状态**: 运行完毕。

### 5.2 Java 层面（Thread.State 六种状态）

![1762959066356](image/1762959066356.png)

```java
public enum State {
    NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED;
}
```

![1764301549678](image/1764301549678.png)

1. **NEW**: 尚未启动（未调用 `start`）。
2. **RUNNABLE**: 正在 JVM 中执行。注意：**Java 的 RUNNABLE 涵盖了 OS 层的可运行、运行和部分阻塞状态**（如 IO 阻塞）。
3. **BLOCKED**: 等待监视器锁以进入同步块。
4. **WAITING**: 等待另一个线程唤醒。
   * `Object.wait()`: 必须配合 `synchronized` 使用。
   * `Thread.join()`: 等待线程执行完毕。
   * `LockSupport.park()`: 挂起当前线程。
5. **TIMED_WAITING**: 具有指定等待时间的等待状态。
   * `Thread.sleep(n)`、`Object.wait(n)`、`Thread.join(n)`、`LockSupport.parkNanos/Until`。
6. **TERMINATED**: 线程执行完毕。

## 6 共享资源问题

### 6.1 示例代码

```java
static int counter = 0;

public static void main(String[] args) throws InterruptedException{
    Thread t1 = new Thread(() ->{
	for(int i = 0;i < 1000;i++){
	    counter++;
	}
    });

    Thread t2 = new Thread(() ->{
	for(int i = 0;i < 1000;i++){
	    counter--;
	}
    });

    t1.start();
    t2.start();
    t1.join();
    t2.join();
    log.info("{}",counter);
}
```

* 上面代码计算结果可能是0，正数或负数
* 单线程没问题：

![1768890582392](image/并发编程核心知识汇总/1768890582392.png)

* 多线程可能的情况：

![1768890609490](image/并发编程核心知识汇总/1768890609490.png)

![1768890622051](image/并发编程核心知识汇总/1768890622051.png)

### 6.2 临界区与静态条件

- **临界区**：一段代码内部存在对**共享资源**的**多线程读写操作**
- **竞态条件**：多个线程在临界区执行，由于代码执行序列不同导致结果无法预测的情况

### 6.3 synchronized 解决方案

- 阻塞式解决方案

- 采用互斥方式让同一时刻最多有一个线程持有**对象锁**

- 互斥和同步都可以用 synchronized 解决

  - 互斥：保证临界区竞态条件，同一时刻只能有一个线程执行临界区代码
  - 同步：线程执行先后顺序不同，需要一个线程等待其他线程

- 语法

- ```java
  synchronized(对象){
      临界区
  }
  ```

- ```java
  
  static final Object room = new Object();
  
  public static void main(String[] args) throws InterruptedException{
      Thread t1 = new Thread(() ->{
          for(int i = 0;i < 1000;i++){
              synchronized(room){
                  counter++;
              }
          }
      });
  
      Thread t2 = new Thread(() ->{
         for(int i = 0;i < 1000;i++){
              synchronized(room){
                  counter--;
              }
          }
      });
  
      t1.start();
      t2.start();
      t1.join();
      t2.join();
      log.info("{}",counter);
  }
  
  class Room{
      private int counter = 0;
      
      public void increment(){
           synchronized(room){
              counter++;
          }
      }  
      
      public void decrement(){
           synchronized(room){
              counter--;
          }
      }
      
      public int getCounter(){
           synchronized(room){
              return counter;
          }
      }
  }
  ```

  ![image-20260120144535145](C:\Users\35160\AppData\Roaming\Typora\typora-user-images\image-20260120144535145.png)

![image-20260120144552354](C:\Users\35160\AppData\Roaming\Typora\typora-user-images\image-20260120144552354.png)
