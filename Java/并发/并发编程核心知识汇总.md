# 并发编程核心知识汇总

## 1. 多线程基础

### 1.1 创建线程的三种方式

1. **继承 Thread 类**：创建一个类继承 `Thread` 类，并重写 `run` 方法。
   ```java
   public class MyThread extends Thread {
       @Override
       public void run() {
           System.out.println(getName() + ": 执行任务");
       }
   }
   ```
2. **实现 Runnable 接口**：创建一个类实现 `Runnable` 接口，并重写 `run` 方法。更灵活，易于与线程池配合。
   ```java
   public class MyRunnable implements Runnable {
       @Override
       public void run() {
           System.out.println(Thread.currentThread().getName() + ": 执行任务");
       }
   }
   ```
3. **实现 Callable 接口 (FutureTask)**：实现 `Callable` 接口，重写 `call` 方法。这种方式可以通过 `FutureTask` 获取任务执行的返回值。
   ```java
   public class CallerTask implements Callable<String> {
       public String call() throws Exception {
           return "Hello, task result!";
       }
   }
   // 使用方式
   FutureTask<String> task = new FutureTask<>(new CallerTask());
   new Thread(task).start();
   String result = task.get(); // 获取结果
   ```

| 创建方式 | 优点 | 缺点 |
| :--- | :--- | :--- |
| **实现 Runnable/Callable** | 避免 Java 单继承局限；适合资源共享；解耦线程与任务。 | 编程稍微复杂，如需访问当前线程需使用 `Thread.currentThread()`。 |
| **继承 Thread** | 编程简单，直接使用 `this` 即可获取当前线程。 | 受限于 Java 单继承；不适合多线程处理同一资源。 |

### 1.2 run() 与 start() 的区别
* **为什么要重写 run()**：默认的 `run()` 方法不执行任何操作。为了让线程执行具体任务，必须重写它。
* `run()`：封装线程执行的代码，直接调用相当于在主线程中执行普通方法。
* `start()`：启动线程，使线程进入“就绪”状态，由 JVM 在合适时机调用此线程的 `run()` 方法。**只有 start() 才能真正开启多线程。**

## 2. 获取线程执行结果 (Future)

### 2.1 Future 接口
提供了异步计算的各种功能：
* `cancel(boolean mayInterrupt)`：尝试取消任务。若任务已完成或无法取消则返回 false。
* `isCancelled()`：任务是否在正常完成前被取消。
* `isDone()`：任务是否已完成（包括正常完成、异常、取消）。
* `get()`：**阻塞**获取结果，直到任务完成。
* `get(timeout, unit)`：在指定时间内获取结果，超时则返回 null 或抛异常。

### 2.2 FutureTask
`FutureTask` 实现了 `RunnableFuture` 接口（继承自 `Runnable` 和 `Future`），既可以作为 `Runnable` 被线程执行，又可以作为 `Future` 获取结果。

---

## 3. 线程运行原理

### 2.1 栈与栈帧
* 线程启动后，虚拟机会为每个线程分配一段**栈内存**。
* 栈由多个**栈帧**（Stack Frame）构成，对应着每次方法调用时占用的内存。
* 每个线程只能有一个**活动栈帧**，对应着当前正在执行的那个方法。

### 2.2 线程上下文切换（Context Switch）
发生情况：
* 线程的 CPU 时间片用完。
* 垃圾回收。
* 有更高优先级的线程需要运行。
* 线程自己调用了 `sleep`、`yield`、`wait`、`join`、`park`、`synchronized`、`lock` 等方法。

当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是**程序计数器**（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的。

---

## 3. 查看进程与线程

### 3.1 操作系统命令
* **Windows**:
  * `tasklist`: 查看所有进程。
  * `taskkill /F /PID <pid>`: 强制杀死进程。
* **Linux**:
  * `ps -fe`: 查看所有进程。
  * `top`: 动态查看进程信息。
  * `kill <pid>`: 杀死进程。

### 3.2 Java 工具
* `jps`: 查看所有 Java 进程。
* `jstack <PID>`: 查看某个 Java 进程内的线程堆栈信息（排查死锁、CPU 飙高常用）。
* `jconsole`: 图形化界面，查看 Java 进程内线程的运行情况。

---

## 4. 线程常用方法

| 方法名 | 作用 | 说明 |
| :--- | :--- | :--- |
| `start()` | 启动新线程 | 每个线程只能调用一次（**不可重复调用**）。 |
| `run()` | 线程启动后执行的逻辑 | 直接调用不会启动新线程。 |
| `join()` / `join(n)` | 等待线程结束 | 使调用方等待该线程结束（或超时）。 |
| `sleep(n)` | 线程休眠 | 状态变为 `TIMED_WAITING`，**不释放锁**。建议在 `while(true)` 循环中调用以防 CPU 空转。 |
| `yield()` | 提示让出 CPU | 状态变为 `RUNNABLE`，具体是否让出依赖调度器。 |
| `interrupt()` | 打断线程 | 设置打断标记；若线程在 sleep/wait/join 会抛异常并清除标记。 |
| `isInterrupted()` | 判断是否被打断 | 不会清除打断标记。 |
| `Thread.interrupted()` | 判断是否被打断 | **静态方法，会清除打断标记**。 |
| `setDaemon(true)` | 设置为守护线程 | 主线程结束，守护线程也会被强制结束（如 GC 线程）。 |
| `getId()` | 获取线程唯一 ID | 线程的长整型标识符。 |
| `getName()` / `setName()` | 获取/修改线程名 | 方便调试和排查问题。 |
| `getPriority()` / `setPriority()` | 获取/修改优先级 | 范围 1-10，具体实现依赖任务调度器。 |
| `isAlive()` | 线程是否存活 | 线程已启动且尚未结束。 |
| `currentThread()` | 获取当前线程 | 静态方法。 |

### 4.1 过时方法（不推荐使用）
以下方法由于容易导致死锁或资源无法释放，已不推荐使用：
* `stop()`: 强制停止线程，可能导致同步资源未释放。
* `suspend()` / `resume()`: 挂起和恢复线程，极易导致死锁。

### 4.2 两阶段终止模式
如何优雅地在一个线程中终止另一个线程？利用 `interrupt`。
![1764300709161](image/heima/1764300709161.png)

---

## 5. 线程生命周期与状态

![1762734021190](image/并发-二哥/1762734021190.png)

### 5.1 操作系统层面（五种状态）
![1764301356509](image/heima/1764301356509.png)

1. **初始状态**: 已创建但未与操作系统关联。
2. **可运行状态**: 等待 CPU 调度。
3. **运行状态**: 正在执行，时间片用完会回到可运行状态。
4. **阻塞状态**: 调用阻塞 API（如读写文件），结束后回到可运行状态。
5. **终止状态**: 运行完毕。

### 5.2 Java 层面（Thread.State 六种状态）
![1762959066356](image/并发-二哥/1762959066356.png)

```java
public enum State {
    NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED;
}
```

![1764301549678](image/heima/1764301549678.png)

1. **NEW**: 尚未启动（未调用 `start`）。
2. **RUNNABLE**: 正在 JVM 中执行。注意：**Java 的 RUNNABLE 涵盖了 OS 层的可运行、运行和部分阻塞状态**（如 IO 阻塞）。
3. **BLOCKED**: 等待监视器锁以进入同步块。
4. **WAITING**: 等待另一个线程唤醒。
   * `Object.wait()`: 必须配合 `synchronized` 使用。
   * `Thread.join()`: 等待线程执行完毕。
   * `LockSupport.park()`: 挂起当前线程。
5. **TIMED_WAITING**: 具有指定等待时间的等待状态。
   * `Thread.sleep(n)`、`Object.wait(n)`、`Thread.join(n)`、`LockSupport.parkNanos/Until`。
6. **TERMINATED**: 线程执行完毕。

---

## 6. 线程安全三要素

1. **原子性**: 一个或多个操作，要么全部执行成功，要么全部不执行。
2. **可见性**: 一个线程对共享变量的修改，其他线程能够立即看到。每个线程有自己的工作内存，通过主内存同步。
![1762966711648](image/并发-二哥/1762966711648.png)
3. **有序性**: 程序执行的顺序按照代码的先后顺序执行（防止指令重排）。

## 6. 线程安全与性能问题

### 6.1 活跃性问题
* **死锁**: 多个线程因互相持有对方需要的锁且不释放，导致无限期等待。
* **活锁**: 线程都在运行且都在修改状态，但因状态依赖导致任何一个线程都无法继续执行。
* **饥饿**: 线程因优先级低或锁始终被其他线程占用，导致一直无法获得执行机会。

### 6.2 性能问题
多线程会带来**创建线程**和**上下文切换**的开销。减少开销的方法：
* **无锁并发**: 锁分段（如 `ConcurrentHashMap`）、CAS 算法（乐观锁）。
* **使用最少线程**: 避免创建不必要的线程。
* **协程**: 在单线程里实现多任务调度。

---

## 7. Java 内存模型 (JMM)

JMM 决定了一个线程对共享变量的写入何时对另一个线程可见。

### 7.1 happens-before 规则
1. **程序顺序规则**: 同一个线程内，前面的操作 happens-before 后面的操作。
2. **监视器锁规则**: 解锁 happens-before 随后的加锁。
3. **volatile 变量规则**: 对 volatile 变量的写 happens-before 随后的读。
4. **传递性**: A h-b B, B h-b C => A h-b C。
5. **start/join 规则**: 线程 start 操作 h-b 线程内任务；线程内任务 h-b 线程 join 返回。

---

## 8. 关键字详解

### 8.1 volatile
* **保证可见性**: 强制从主内存读写变量。
* **禁止指令重排**：通过插入**内存屏障**确保顺序。
  * **写屏障（Write Barrier）**：在写入 volatile 变量时，确保屏障之前的所有变量写入都同步到主内存。
  * **读屏障（Read Barrier）**：在读取 volatile 变量时，确保屏障之后的所有读操作都从主内存读取。
* **注意**：`volatile` **不能保证原子性**（如 `i++`）。

### 8.2 synchronized
* **应用方式**: 同步方法、同步静态方法、同步代码块。
* **特性**: **原子性、可见性、有序性、可重入性**。
* **原理**: 每个对象都有一把锁（Monitor）。
* **可重入**: 线程已持有该对象锁时，再次请求该锁仍能成功。

## 10. Java 并发编程模型

并发编程主要解决线程间的**通信**和**同步**：
* **通信**：线程间以何种机制交换信息（消息传递 vs 共享内存）。
* **同步**：控制不同线程间操作发生的相对顺序。

![1763001102459](image/并发-二哥/1763001102459.png)

* **Java 采用的是共享内存模型**。

![1763001174858](image/并发-二哥/1763001174858.png)

---

## 11. synchronized 锁升级过程

为了提高性能，JVM 对 `synchronized` 进行了优化。

### 11.1 Java 对象头结构

在 JVM 中，对象在内存中的布局分为：对象头、实例数据、对齐填充。对象头包含：

| 长度 | 内容 | 说明 |
| :--- | :--- | :--- |
| 32/64 bit | **Mark Word** | 存储对象的 hashCode、锁信息等（见下表）。 |
| 32/64 bit | **Class Metadata Address** | 存储到对象类型数据的指针。 |
| 32/64 bit | **Array length** | 数组的长度（仅当对象是数组时存在）。 |

### 11.2 锁的优缺点对比

| 锁状态 | 优点 | 缺点 | 适用场景 |
| :--- | :--- | :--- | :--- |
| **偏向锁** | 加/解锁开销极低（仅纳秒级）。 | 存在竞争时撤销锁有额外消耗。 | 只有一个线程访问同步块。 |
| **轻量级锁** | 竞争线程不阻塞（自旋），响应快。 | 始终得不到锁时自旋消耗 CPU。 | 同步块执行极快，竞争不激烈。 |
| **重量级锁** | 线程不自旋，不消耗 CPU。 | 线程阻塞，上下文切换开销大。 | 追求吞吐量，同步块执行时间长。 |

### 11.3 Mark Word 结构
Mark Word 的位分布根据锁状态而变化（以 64 位为例）：

| 锁状态 | 25 bit | 31 bit | 1 bit (未用) | 4 bit (分代年龄) | 1 bit (是否偏向) | 2 bit (锁标志位) |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **无锁** | unused | hashCode | - | age | 0 | 01 |
| **偏向锁** | **Thread ID** | **Epoch** | - | age | 1 | 01 |
| **轻量级锁** | **指向栈中锁记录的指针** | | | | - | 00 |
| **重量级锁** | **指向互斥量（Monitor）的指针** | | | | - | 10 |
| **GC 标记** | | | | | - | 11 |

### 11.4 偏向锁执行流程
偏向锁会偏向于第一个访问锁的线程，若后续无竞争，则持有锁的线程永远不需要触发同步。
![1763145936612](image/并发-二哥/1763145936612.png)

### 11.5 锁状态转换图
![1762961121575](image/并发-二哥/1762961121575.png)
