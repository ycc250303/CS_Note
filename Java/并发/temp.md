## 6. 线程安全三要素

1. **原子性**: 一个或多个操作，要么全部执行成功，要么全部不执行。
2. **可见性**: 一个线程对共享变量的修改，其他线程能够立即看到。每个线程有自己的工作内存，通过主内存同步。
   ![1762966711648](image/1762966711648.png)
3. **有序性**: 程序执行的顺序按照代码的先后顺序执行（防止指令重排）。

## 6. 线程安全与性能问题

### 6.1 活跃性问题

* **死锁**: 多个线程因互相持有对方需要的锁且不释放，导致无限期等待。
* **活锁**: 线程都在运行且都在修改状态，但因状态依赖导致任何一个线程都无法继续执行。
* **饥饿**: 线程因优先级低或锁始终被其他线程占用，导致一直无法获得执行机会。

### 6.2 性能问题

多线程会带来**创建线程**和**上下文切换**的开销。减少开销的方法：

* **无锁并发**: 锁分段（如 `ConcurrentHashMap`）、CAS 算法（乐观锁）。
* **使用最少线程**: 避免创建不必要的线程。
* **协程**: 在单线程里实现多任务调度。

---

## 7. Java 内存模型 (JMM)

JMM 决定了一个线程对共享变量的写入何时对另一个线程可见。

### 7.1 happens-before 规则

1. **程序顺序规则**: 同一个线程内，前面的操作 happens-before 后面的操作。
2. **监视器锁规则**: 解锁 happens-before 随后的加锁。
3. **volatile 变量规则**: 对 volatile 变量的写 happens-before 随后的读。
4. **传递性**: A h-b B, B h-b C => A h-b C。
5. **start/join 规则**: 线程 start 操作 h-b 线程内任务；线程内任务 h-b 线程 join 返回。

---

## 8. 关键字详解

### 8.1 volatile

* **保证可见性**: 强制从主内存读写变量。
* **禁止指令重排**：通过插入**内存屏障**确保顺序。
  * **写屏障（Write Barrier）**：在写入 volatile 变量时，确保屏障之前的所有变量写入都同步到主内存。
  * **读屏障（Read Barrier）**：在读取 volatile 变量时，确保屏障之后的所有读操作都从主内存读取。
* **注意**：`volatile` **不能保证原子性**（如 `i++`）。

### 8.2 synchronized

* **应用方式**: 同步方法、同步静态方法、同步代码块。
* **特性**: **原子性、可见性、有序性、可重入性**。
* **原理**: 每个对象都有一把锁（Monitor）。
* **可重入**: 线程已持有该对象锁时，再次请求该锁仍能成功。

## 10. Java 并发编程模型

并发编程主要解决线程间的**通信**和**同步**：

* **通信**：线程间以何种机制交换信息（消息传递 vs 共享内存）。
* **同步**：控制不同线程间操作发生的相对顺序。

![1763001102459](image/1763001102459.png)

* **Java 采用的是共享内存模型**。

![1763001174858](image/1763001174858.png)

---

## 11. synchronized 锁升级过程

为了提高性能，JVM 对 `synchronized` 进行了优化。

### 11.1 Java 对象头结构

在 JVM 中，对象在内存中的布局分为：对象头、实例数据、对齐填充。对象头包含：

| 长度      | 内容                       | 说明                                      |
| :-------- | :------------------------- | :---------------------------------------- |
| 32/64 bit | **Mark Word**              | 存储对象的 hashCode、锁信息等（见下表）。 |
| 32/64 bit | **Class Metadata Address** | 存储到对象类型数据的指针。                |
| 32/64 bit | **Array length**           | 数组的长度（仅当对象是数组时存在）。      |

### 11.2 锁的优缺点对比

| 锁状态       | 优点                             | 缺点                         | 适用场景                       |
| :----------- | :------------------------------- | :--------------------------- | :----------------------------- |
| **偏向锁**   | 加/解锁开销极低（仅纳秒级）。    | 存在竞争时撤销锁有额外消耗。 | 只有一个线程访问同步块。       |
| **轻量级锁** | 竞争线程不阻塞（自旋），响应快。 | 始终得不到锁时自旋消耗 CPU。 | 同步块执行极快，竞争不激烈。   |
| **重量级锁** | 线程不自旋，不消耗 CPU。         | 线程阻塞，上下文切换开销大。 | 追求吞吐量，同步块执行时间长。 |

### 11.3 Mark Word 结构

Mark Word 的位分布根据锁状态而变化（以 64 位为例）：

| 锁状态       | 25 bit                          | 31 bit    | 1 bit (未用) | 4 bit (分代年龄) | 1 bit (是否偏向) | 2 bit (锁标志位) |
| :----------- | :------------------------------ | :-------- | :----------- | :--------------- | :--------------- | :--------------- |
| **无锁**     | unused                          | hashCode  | -            | age              | 0                | 01               |
| **偏向锁**   | **Thread ID**                   | **Epoch** | -            | age              | 1                | 01               |
| **轻量级锁** | **指向栈中锁记录的指针**        |           |              |                  | -                | 00               |
| **重量级锁** | **指向互斥量（Monitor）的指针** |           |              |                  | -                | 10               |
| **GC 标记**  |                                 |           |              |                  | -                | 11               |

### 11.4 偏向锁执行流程

偏向锁会偏向于第一个访问锁的线程，若后续无竞争，则持有锁的线程永远不需要触发同步。
![1763145936612](image/1763145936612.png)

### 11.5 锁状态转换图

![1762961121575](image/1762961121575.png)
